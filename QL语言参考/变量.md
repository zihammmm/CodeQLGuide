# 变量
QL中的变量的使用方式与代数或逻辑中的变量类似。它们代表一组值，这些值通常受到公式的限制。  

这与其他一些编程语言中的变量不同，在这些语言中，变量表示了可能包含数据的内存位置。这些数据也会随着时间而变化。例如，在QL中，$n = n + 1$ 是一个等式，只有当 *n* 等于 *n + 1* 时才成立(所以实际上它对任何数值都不成立)。在Java中，$n = n + 1$ 并不是一个等式，而是一个赋值，通过在当前值上加1来改变 *n* 的值。  

## 声明一个变量(Declaring a variable)
所有变量声明都由变量的类型和名称组成。名称可以是任何以大写或小写字母开头的标识符。  

例如， *int i*, *SsaDefinitionNode node* 和 *LocalScopeVariable lsv* 分别声明了 *int*型变量 *i*，*SsaDefinitionNode* 型变量 *node* 和 *LocalScopeVariable* 型变量 *lsv*。  

变量声明可以出现在不同的上下文中，例如，在select子句中，在量化公式中，作为谓词的参数，等等。  

从概念上讲，可以将变量看作是保存其类型所允许的所有值，但不受任何进一步的约束。  

例如，考虑下面的select子句:  
```ql
from int i
where i in [0 .. 9]
select i
```  
根据它的类型，变量 *i* 可以包含所有整数。但是，它受到公式 *i in [[0 ..9]* 的约束。因此，select子句的结果是0到9之间的10个数字(包括9)。  

顺便说一句，注意下面的查询会导致编译时错误:  
```ql
from int i
select i
```  
理论上，它会有无穷多个结果，因为变量i不受有限个可能值的限制。更多信息请查看“绑定”。  

## 自由变量和约束变量(Free and bound variables) 
变量可以有不同的角色。有些变量是 **自由** 的，它们的值直接影响使用它们的表达式的值，或者影响使用它们的公式是否成立。其他变量(称为 **约束变量** )被限制为特定的值集。  

在一个示例中理解这种区别可能是最容易的。看看下面的表达式:  
```ql
"hello".indexOf("l")

min(float f | f in [-3 .. 3])

(i + 7) * 3

x.sqrt()
```  
第一个表达式没有任何变量。它查找字符串 *“hello”* 中 *“l”* 出现的位置的(以零为基础的)索引，因此计算结果为2和3。  

第二个表达式的计算结果是-3，是 $[-3 .. 3]$ 范围内的最小值。尽管这个表达式使用了一个变量 *f* ，但它只是一个占位符或“虚拟”变量，而且您不能给它赋值。你可以用不同的变量替换 *f* 而不改变表达式的含义。例如，$min(float f | f in [-3 .. 3])$ 总是等于 $min(float other | other in [-3 .. 3]) $。这就是一个约束变量的例子。  

那么表达式 $(i + 7) * 3$ 和 $x.sqrt()$ 呢?在这两种情况下，表达式的值取决于分别赋给变量 *i* 和 *x* 的值。换句话说，变量的值对表达式的值有影响。这些是自由变量的例子。  

类似地，如果公式包含自由变量，则公式可以成立或不成立，这取决于赋给这些变量[1]的值。例如:  
```ql
"hello".indexOf("l") = 1

min(float f | f in [-3 .. 3]) = -3

(i + 7) * 3 instanceof int

exists(float y | x.sqrt() = y)
```
第一个公式不包含任何变量，并且它从不成立(因为 $“hello”. indexof(“l”)$ 的值是2和3，而不是1)。  

第二个公式只包含一个约束变量，因此不受对该变量的更改的影响。因为 $min(float f | f in [-3 .. 3])$ 等于 $-3$，这个公式总是成立的。  

第三个公式包含一个自由变量 *i* 。公式是否成立取决于给 *i* 赋了什么值。例如，如果给 *i* 赋了1或2(或任何其他 *int* )，则公式成立。另一方面，如果 *i* 被赋值为 $3.5$ ，那么它就不成立。  

最后一个公式包含一个自由变量 *x* 和一个约束变量 *y* 。如果 *x* 被赋给一个非负数，则最后一个公式成立。另一方面，如果 *x* 被赋值为-9，那么这个公式就不成立。变量 *y* 不影响公式是否成立。  

有关如何计算对自由变量的赋值的更多信息，请参见“QL程序的计算”。  

### 脚注
> [1] 这稍微简化了一下。有些公式总是正确的或错误的，不管对它们的自由变量的赋值是什么。然而，当你写QL的时候，你通常不会使用这些。例如，$a = a$ 总是为真(称为重言式)，而 $x and not x$ 总是为假。